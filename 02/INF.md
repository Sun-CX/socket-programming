* 学习 REUSEADDR
> 服务器端应尽可能使用 reuseaddr 选项，使得不必等待 TIME_WAIT 状态消失就可以重启服务器

---
* 多客户端的连接（多进程实现）
> 已知问题，当客户端断开连接后，子进程处于失去响应状态，不能正常退出

什么是 defunct 进程(僵尸进程)?
在 Linux 系统中,一个进程结束了,但是他的父进程没有等待(调用 wait / waitpid)他,那么他将变成一个僵尸进程。当用ps命令观察进程的执行状态时,看到这些进程的状态栏为defunct。僵尸进程是一个早已死亡的进程,但在进程表(processs table)中仍占了一个位置(slot)。
但是如果该进程的父进程已经先结束了,那么该进程就不会变成僵尸进程。因为每个进程结束的时候,系统都会扫描当前系统中所运行的所有进程,看看有没有哪个进程是刚刚结束的这个进程的子进程,如果是的话,就由Init进程来接管他,成为他的父进程,从而保证每个进程都会有一个父进程。而Init进程会自动wait其子进程,因此被Init接管的所有进程都不会变成僵尸进程。

可以通过kill僵尸进程的父进程来杀死僵尸进程。


#### 避免产生僵尸进程
给进程设置僵尸状态的目的是维护子进程的信息，以便父进程在以后某个时间获取。这些信息包括子进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们(init进程将wait它们，从而去除僵尸状态)。

如果子进程先于父进程退出， 同时父进程又没有调用wait/waitpid，则该子进程将成为僵尸进程。

一般，为了防止产生僵尸进程，在fork子进程之后我们都要wait它们；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的。

假设有一个client/server的程序，对于每一个连接过来的client，server都启动一个新的进程去处理来自这个client的请求。然后我们有一个client进程，在这个进程内，发起了多个到server的请求（假设5个），则server会fork 5个子进程来读取client输入并处理（同时，当客户端关闭套接字的时候，每个子进程都退出）；当我们终止这个client进程的时候 ，内核将自动关闭所有由这个client进程打开的套接字，那么由这个client进程发起的5个连接基本在同一时刻终止。这就引发了5个FIN，每个连接一个。server端接受到这5个FIN的时候，5个子进程基本在同一时刻终止。这就又导致差不多在同一时刻递交5个SIGCHLD信号给父进程，

正是这种同一信号多个实例的递交造成了我们即将查看的问题。

建立信号处理函数并在其中调用wait并不足以防止出现僵尸进程，其原因在于：所有5个信号都在信号处理函数执行之前产生，而信号处理函数只执行一次，因为Unix信号一般是不排队的

正确的解决办法是调用waitpid而不是wait，这个办法的方法为：信号处理函数中，在一个循环内调用waitpid，以获取所有已终止子进程的状态。我们必须指定WNOHANG选项，他告知waitpid在有尚未终止的子进程在运行时不要阻塞。（我们不能在循环内调用wait，因为没有办法防止wait在尚有未终止的子进程在运行时阻塞，wait将会阻塞到现有的子进程中第一个终止为止）

---
* 点对点聊天程序的实现：由于会出现子进程不能正常退出的情况，因此需要使用信号

kill掉父进程，子进程不同的运行方式
转载风吹过的时光 最后发布于2014-09-10 13:42:55 阅读数 9606  收藏
展开
第一种情况：
[root@qht2 ~]# ps -ef | grep httpd
root 3799 1 0 10:41 pts/0 00:00:00 /usr/sbin/nss_pcache off /etc/httpd/alias
root 3803 1 3 10:41 ? 00:00:00 /usr/sbin/httpd
apache 3807 3803 0 10:41 ? 00:00:00 /usr/sbin/httpd
apache 3808 3803 0 10:41 ? 00:00:00 /usr/sbin/httpd
apache 3809 3803 0 10:41 ? 00:00:00 /usr/sbin/httpd
apache 3810 3803 0 10:41 ? 00:00:00 /usr/sbin/httpd
apache 3811 3803 0 10:41 ? 00:00:00 /usr/sbin/httpd
apache 3812 3803 0 10:41 ? 00:00:00 /usr/sbin/httpd
apache 3813 3803 0 10:41 ? 00:00:00 /usr/sbin/httpd
apache 3814 3803 0 10:41 ? 00:00:00 /usr/sbin/httpd
root 3816 3749 0 10:42 pts/0 00:00:00 grep httpd
[root@qht2 ~]# kill 3803
[root@qht2 ~]# ps -ef | grep httpd
root 3820 3749 0 10:42 pts/0 00:00:00 grep httpd
显然kill掉父进程，子进程也消亡了！
第二种情况：
我写了两个脚本a.sh 和b.sh， 在a.sh中调用b.sh，运行后显然有两个进程，而且a.sh为b.sh的父进程，然后我再另外一个terminal中kill 掉a.sh进程，但b.sh过寄给init进程，而不会终止！
我的例子如下：
[root@qht2 ~]# cat a.sh 
#!/bin/sh
echo "A Begin"
./b.sh
echo "A End"
[root@qht2 ~]# cat b.sh 
#!/bin/sh 
echo "B Begin"
sleep 180
mkdir abcdef
echo "B End"
[root@qht2 ~]# ./a.sh 
A Begin
B Begin
在这里等待（因为b.sh中有sleep 180）
打开另一个terminal，查看进程
[root@qht2 ~]# ps -ef | grep sh
。。。。。。
root 3984 3749 0 11:05 pts/0 00:00:00 /bin/sh ./a.sh
root 3985 3984 0 11:05 pts/0 00:00:00 /bin/sh ./b.sh ##显然b.sh是a.sh的子进程
root 3990 3838 0 11:05 pts/1 00:00:00 grep sh 
[root@qht2 ~]# kill 3984
[root@qht2 ~]# ps -ef | grep sh
。。。。。。
root 3985 1 0 11:05 pts/0 00:00:00 /bin/sh ./b.sh
root 3992 3838 2 11:06 pts/1 00:00:00 grep sh
第一ternimal中的显示如下：
[root@qht2 ~]# ./a.sh 
A Begin
B Begin
Terminated
但b.sh还是会运行（因为生成了abcdef目录）！
这两种情况的区别是：
父进程退出,子进程被init领养,继续运行,这才是正常的吧
而前一个,从名字看明显是一个守护进程,id=3803的是会话首进程,也是进程组的组长,KILL掉它,会导致SIGHUP发送给该进程组的每一个进程(就是所有父进程为3803的那些),默认情况下,SIGHUP会终止进程,所以全没了.
详细解释：
所有进程都是属于一个进程组的,而进程组又属于一个会话.
普通的进程所属的会话有控制终端,守护进程所属会话没有控制终端.
普通会话的首进程,同时也是建立与控制终端联系的进程,在它被KILL掉时,会向前台进程组就(a.sh)发送SIGHUP信号.默认情况下,接收到SIGHUP的进程会被终止.此时后台进程组(b.sh)不受影响.
守护进程的会话,因为没有控制终端,所以就没有前后台进程组之分,会话首进程同时也是进程组组长.它被KILL掉会向该组每个进程发送SIGHUP,导致组中进程被中止.
第二个试验,一个脚本调用另一个脚本的行为,创建了一个新的进程组,脚本a.sh是进程组组长,但却不是所在会话的首进程或控制进程,所以它被KILL掉,不影响同组的进程(b.sh),此时init进程会自动领养脚本B所在进程,并在它运行到结束时回收它所占用的资源.
可以用ps -eo pid,ppid,pgrp,session,comm跑一下.
对于第一种情况,就是守护进程,应该会发现那一堆进程的session(会话ID)和pgrp(组ID)都一样且是相同的,而且正好等于子进程的ppid,同时也是你KILL掉那个进程的pid.这样可以证实你KILL掉的是会话首进程.
对于第二种情况,你会发现,进程A和B,session和pgrp是一样的,但两者却并不相同,session的值虽无法确定,但pgrp却应该正好是进程A的pid,这说明了进程A是组长但却不是会话首进程,所以KILL掉它不会导致子进程被结束.
[root@qht2 ~]# ps -eo pid,ppid,pgrp,session,comm
  PID  PPID  PGRP  SESS COMMAND
 1     0     1      1   init
  ***

 3621     1  3621  3621 httpd
 3626  3621  3621  3621 httpd
 3627  3621  3621  3621 httpd
 3628  3621  3621  3621 httpd
 3629  3621  3621  3621 httpd
 3630  3621  3621  3621 httpd
 3631  3621  3621  3621 httpd
 3632  3621  3621  3621 httpd
 3633  3621  3621  3621 httpd
 3643  3574  3643  3574 a.sh
 3644  3643  3643  3574 b.sh
 3645  3644  3643  3574 sleep
 3646  3571  3646  3646 bash
 3674  3646  3674  3646 ps
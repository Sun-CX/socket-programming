#### 5 种 IO 模型:
* 阻塞 IO
* 非阻塞 IO `fcntl(fd, F_SETFL, flag|0_NONBLOCK)`
  > 应用范围较窄，因为需要忙等待
* IO 复用模式（select 模式）：阻塞时机提前到了 select，一旦有 IO 请求，调用 recv/read 就不会阻塞了。其本质思想就是用 select 来管理多个 IO
* 信号驱动 IO（不常用）：安装 SIGIO 信号，一旦数据到来，以信号的形式来通知应用程序来接收数据
* 异步 IO（效率高，有 bug，相当于 Windows 下的完成端口 IOCP）：aio_read 来实现，其会提交一个请求，且提供一个 buffer，即使内核没有数据到来，该函数也会立刻返回；当有数据到来时，内核会自动将数据拷贝到应用层的缓冲区，一旦复制完成，会通过信号来通知应用进程的程序。
与信号驱动 IO 的不同在于，一旦得到信号，数据已经从内核拷贝到用户空间了。数据是从内核直接推送到用户进程的缓冲区，所以这是一种推（push）的机制，推的机制比拉的机制效率要高一些。

---
#### select 读、写、异常事件的发生条件
##### 可读
1. 套接口缓冲区有数据可读
2. 接收到对等方发送的 FIN 报文段，读操作将返回 0
3. 如果是监听套接口，已完成连接队列不为空时
4. 套接口上发生了一个错误待处理，错误可通过 getsockopt 指定 SO_ERROR 选项来获取

##### 可写
1. 套接口发送缓冲区有空间可以容纳数据
2. 连接的写一半关闭：即收到 RST 报文段之后，再次调用 write 操作
3. 套接口上发生了一个错误待处理，错误可通过 getsockopt 指定 SO_ERROR 选项来获取

##### 异常
1. 套接口存在带外数据

--- 
#### 关于文件描述符
0：标准输入
1：标准输出
2：标准错误
3：新打开的文件描述符